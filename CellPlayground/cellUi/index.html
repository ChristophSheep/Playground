<html>
<head>
    <script type="text/javascript">

        var paper;
        var size;

        function init() {
            paper = getPaper()
            size  = getSize() 

            // Default
            paper.pointSize = 1.0
            paper.DEBUG = true

            // Start animation
            window.requestAnimationFrame(draw)
        }

        function getPaper() {
            return document.getElementById("scene").getContext("2d")
        }

        function getSize() {
            width  = document.getElementById("scene").width
            height = document.getElementById("scene").height
            return {width:width,height:height}
        }

        //
        // HELPERS
        //
        function deg2rad(x) {
            return (x/180.0) * Math.PI
        }

        function clamp(min,max,val) {
            if (val < min) {
                val = 0
            }
            if (val > max) {
                val = 100
            }
            return val
        }

        function polar(radius,alpha) {
            x = radius*Math.cos(deg2rad(alpha))
            y = radius*Math.sin(deg2rad(alpha))
            return {x:x,y:y}
        }

        function range(n) {
            function idx (_,i) {
                return i
            }
            return Array
                .apply(null, Array(n))
                .map(idx)
        }

         // Bezier 3. Grades - start,end point and 2 control points
        //
        // 0 <= t <= 1
        //
        function bezier3(t,p0,p1,p2,p3) {

            if (0.0 <= t && t <= 1.0) {

                /*
                
                Bernstein polynoms
                ------------------

                B03 =       (1-t)*(1-t)*(1-t)
                B13 = 3  *t*(1-t)*(1-t)
                B23 = 3*t*t*(1-t)
                B33 = t*t*t

                */

                t1  = (1-t)
                t2  = t1*t1
                t3  = t2*t1
                tt3 = 3*t
                B03 =       (t3)
                B13 = tt3  *(t2)
                B23 = tt3*t*(t1)
                B33 = t*t*t

                xt = p0.x*B03 + p1.x*B13 + p2.x*B23 + p3.x*B33
                yt = p0.y*B03 + p1.y*B13 + p2.y*B23 + p3.y*B33

                return {x:xt, y:yt}   
            }

            return undefined
        }

        //
        // SHAPES
        //

        function point(pt) {
            return function() {
                paper.beginPath()
                paper.arc(pt.x, pt.y, paper.pointSize, 0, Math.PI *2, true)
                paper.fill()
                paper.stroke()
            }
        }

        function circle(r) {
            return function() {
                paper.beginPath()
                paper.arc(0, 0, r, 0, Math.PI *2, true)
                paper.fill()
                paper.stroke()
            };
        }

        function arc(r, a, b) {
            return function() {
                paper.beginPath()
                paper.arc(0, 0, r, deg2rad(a), deg2rad(b), false)
                paper.stroke()
            }
        }
 
        function rect(w, h) {
            return function() {
                paper.fillRect  (-w/2, -h/2, w, h)
                paper.strokeRect(-w/2, -h/2, w, h)
            }
        }

        function line(p1,p2) {
            return function() {
                paper.beginPath()
                paper.moveTo(p1.x,p1.y)
                paper.lineTo(p2.x,p2.y)
                paper.stroke()
            }
        }

        function polyline(pts) {
            return function() {
                paper.beginPath()
                pts.forEach(function(pt,i){
                    if (i === 0) {
                        paper.moveTo(pt.x,pt.y)
                    } else {
                        paper.lineTo(pt.x,pt.y)
                    }
                })
                paper.stroke()
            }
        }

        function bezCurve(p1,cp1,cp2,p2) {

            curve = [
                function() {
                    paper.beginPath()
                    paper.moveTo(p1.x,p1.y)
                    paper.bezierCurveTo(cp1.x,cp1.y,cp2.x,cp2.y,p2.x,p2.y)
                    paper.stroke()
                }, 
            ]

            if (paper.DEBUG) {

                st = {strokeColor:'grey', lineWidth:1}
                sp = {strokeColor:'blue', lineWidth:1, fillColor: 'blue', pointSize: 1.2}

                tangents = [
                    style( 
                        st,
                        line(p1,cp1),
                    ),
                    style(
                        st,
                        line(cp2,p2),
                    ),
                    style(sp,
                        point(cp1)
                    ),
                    style(sp,
                        point(cp2)
                    ),
                ]

                curve = tangents.concat(curve)
            }

            return group(curve)
        }

        function quadCurve(p1,cp,p2) {
            curve = [function() {
                paper.beginPath()
                paper.moveTo(p1.x,p1.y)
                paper.quadraticCurveTo(cp.x,cp.y,p2.x,p2.y)
                paper.stroke()
            }]

            if (paper.DEBUG) {

                st = {strokeColor:'lightgrey'}
                sp = {strokeColor:'blue', fillColor: 'blue', pointSize: 1.2}

                tangents = [
                    style(st,
                        line(p1,cp),
                    ),
                    style(st,
                        line(cp,p2),
                    ),
                    style(sp,
                        point(cp)
                    ),
                ]
                curve = tangents.concat(curve)  
            }

            return group(curve)
        }

        function text(str) {
            return function() {
                paper.fillText(str, 0, 0)
                paper.strokeText(str, 0, 0)
            }
        }

        //
        // MODIFIERS
        //
        function group(fns) {
            return function() {
                fns.forEach(function(fn) {
                    fn()        
                })
            }
        }

        function transform(t, fn) {
            return function() {
                paper.save()
                    paper.translate(t.x,  t.y )
                    paper.scale    (t.sx, t.sy)
                    fn()
                paper.restore()
            }
        }

        function style(s, fn) {
            return function() {
                
                if (s.pointSize !== undefined) {
                    savedPointSize = paper.pointSize
                }

                paper.save()

                    paper.font         = s.font
                    paper.textAlign    = s.textAlign
                    paper.textBaseline = s.textBaseline

                    paper.fillStyle    = s.fillColor
                    paper.strokeStyle  = s.strokeColor
                    
                    paper.lineWidth    = s.lineWidth

                    if (s.pointSize !== undefined) {
                        paper.pointSize  = s.pointSize
                    }

                    if (s.lineDash !== undefined) {
                        paper.setLineDash(s.lineDash)
                    }

                    if (s.lineDashOffset !== undefined) {
                        paper.lineDashOffset = s.lineDashOffset
                    }
                    
                    fn()

                paper.restore()

                if (s.pointSize !== undefined) {
                    paper.pointSize = savedPointSize
                }
            }
        }

        //
        // Cell components
        //

        // Cell background
        //
        function background(radius) {
            return circle(radius)
        }

        // Dendride (area)
        //
        function drendride(radius, percent) {

            percent = clamp(0,100,percent)
            
            alpha = 40
            width = radius*0.25

            alphaFull    = 360-alpha*2
            alphaPercent = (alphaFull*percent/100)

            alphaEnd     = 360-alpha
            alphaStart   = alphaEnd - alphaPercent 

            return group([
                // percentage
                style(
                    {lineWidth:width},
                    arc(radius-width/2, alphaStart, alphaEnd)
                ),
                // borders
                style(
                    {lineWidth:width},
                    arc(radius-width/2, alpha, alpha+1)
                ),
                style(
                    {lineWidth:width},
                    arc(radius-width/2, alphaEnd-1, alphaEnd)
                ),
                arc(radius-width, alpha, alphaEnd)
            ])     
        }

        // Cell body / soma
        //
        function soma(radius, percent) {
            fontSize = radius * 0.4
            kradius = 3 + radius*0.5 * percent/100
            str = percent+''

            txtStyle = {
                fillColor    : 'white' ,
                strokeColor  : 'white' ,
                textAlign    : 'center',
                textBaseline : 'middle',
                font         : fontSize+'px Arial',
            }

            stext = transform({
                    x:radius/2,
                    y:0
                },
                style(
                    txtStyle,
                    text(str)
                )
            )

            kernel = style({
                    fillColor:"rgba(0,0,255,0.5)", 
                    lineWidth:2
                },
                circle(kradius)
            )

            threshold = style({
                strokeColor:"red",
                fillColor:"rgba(0,0,0,0)",
                lineDash:[7,1,1,1],
                lineDashOffset: 2,
                },
                circle(10)
            )

            return group([
                threshold,
                kernel,
                stext,
            ])
        }

        // Axon
        //
        function axon(radius, percent) {

            function getColor(percent) {
                if (percent < 95) {
                    fillColorColor = "lightblue"
                } else {
                    fillColorColor = "blue"
                }
                return fillColorColor
            }

            length = 120
            fillColorColor = getColor(percent)
            return transform(
                {x:radius,y:0},
                style(
                    {fillColor:fillColorColor},
                    group([
                        transform(
                            {x:length/2,y:0},
                            rect(length,radius*0.1)
                        ),
                        circle(radius*0.15),
                    ])
                )
            )
        }

     
        // Synapse
        //
        function synapse(radius, weight, alpha) {
            function getRadius(radius, weight) {
                if (weight < 0) {
                    weight = weight * -1.0
                }
                return radius*weight
            }

            function getColor(weight) {
                if (weight < 0) {
                    return "lightwhite"
                }
                return "blue"
            }

            fact = 0.05
            pos = polar(radius,alpha)
            radius = radius*fact
            return transform(
                pos,
                style(
                    {fillColor:getColor(weight)},
                    circle(getRadius(radius, weight))
                )
            )
        }

        function connection(radius, weight, alpha) {
            p2 = polar(radius,alpha)
            cp = polar(radius*1.5,alpha)
            p1 = polar(radius*1.5,alpha)
            p1.x = - 150
            return group([
                quadCurve(p1,cp,p2),
                synapse(radius,weight,alpha),
            ])
        }

        function makeCons(weights) {
            
            alpha = 40
            lenAlpha = 360 - 2*alpha

            count = weights.length
            delta = lenAlpha / (count + 1)

            connections = []
            weights.forEach(function(w,i){
                connections.push(
                    connection(radius, w, alpha + delta*(i+1))
                )  
            })

            return connections
        }

        function cell(radius,s,percent) {
            
            weights = [1,2,3,4,5,6,7,8,9,10]
            weights.forEach(function(w,i){
                weights[i] = Math.random() * 4.0 - 2.0
                console.debug(weights[i])
            })
            connections = makeCons(weights)

            return style(s,
                group(connections.concat([
                    axon(radius,percent),
                    background(radius),
                    drendride(radius, percent),
                    soma(radius, percent)
                    ])
                )
            )
        }

       

        // Diagram (action potential)
        //
        function diagram() {

            function bezCurveN(p1, cp1, cp2, p2) {
                N = 5
                ns = range(N+1)
                ts = ns.map(function(n){return n/N})

                pts = ts.map(function(t){
                    return bezier3(t, p1, cp1, cp2, p2)
                })

                return polyline(pts)
            }

            function curve() {

                rest = 0    // rest level
                thre = 15   // threshold level
                max  = 100
                
                t1 = 0      // at rest
                t2 = 50     // reach threshold
                t3 = 60     // reach max
                t4 = 70     // go min
                t5 = 100    // go back rest

                tt = 5      // tangent offset

                // up to threshold
                p1  = {x:t1,      y: rest}
                cp1 = {x:t1+t2/2, y: rest}
                cp2 = {x:t2,      y: rest}
                p2  = {x:t2,      y: thre}

                // up - ++ rush in
                p3 = p2
                cp3 = {x:t2,    y:  0}
                cp4 = {x:t2+tt, y:max}
                p4  = {x:t3,    y:max}
            
                // down - ++ rush out
                p5 = p4
                cp5 = {x:t3+tt, y:+max }
                cp6 = {x:t4-tt, y:-thre}
                p6  = {x:t4,    y:-thre}

                // back to rest level
                p7 = p6
                cp7 = {x:t4+tt*1, y:-thre}
                cp8 = {x:t5-tt*4, y:+rest}
                p8  = {x:t5,      y:+rest}

                // canvas bezier curve
                a = group([
                    bezCurve(p1, cp1, cp2, p2),
                    bezCurve(p3, cp3, cp4, p4),
                    bezCurve(p5, cp5, cp6, p6),
                    bezCurve(p7, cp7, cp8, p8),   
                ])

                // self calced bezier
                b = group([
                    bezCurveN(p1, cp1, cp2, p2),
                    bezCurveN(p3, cp3, cp4, p4),
                    bezCurveN(p5, cp5, cp6, p6),
                    bezCurveN(p7, cp7, cp8, p8),   
                ])

                return {a:a, b:b}
            }

            function threshold() {
                p1 = {x:0,  y:15}
                p2 = {x:120,y:15}
                return line(p1,p2)
            }

            function axis() {
                xsize = 120
                ysize = 100
                
                p0 = {x:0,    y:    0}
                py = {x:0,    y:ysize}
                px = {x:xsize,y:    0}
                
                return polyline([py,p0,px])
            }

            curveAB = curve()

            return group([
                
                style({
                        strokeColor:'grey', 
                        lineWidth:1
                    },
                    axis()
                ),

                style({
                        strokeColor:'rgba(170,170,170,0.4)',
                        //lineDash:[7,2],
                        lineWidth:5,
                
                    },
                    curveAB.a
                ),

                style({
                        strokeColor:'blue',
                        lineDash:[3,2],
                    },
                    curveAB.b
                ),

                style({
                        strokeColor:'green',
                        lineDash:[13,2,1,2],
                    },
                    threshold()
                )
            ])
        }

        // Clear scene
        //
        function clear() {
            //paper.fillStyle = 'rgba(255,255,255,0.3)'
            //paper.fillRect(0,0,size.width,size.height);
        
            paper.clearRect(0,0,size.width,size.height); 
        }

        // Draw scene
        //
        function draw() {

            // TODO: check
            // paper.globalCompositeOperation = 'destination-over';
            
            clear()

            var s = {
                fillColor  : "lightgrey",
                strokeColor: "blue", // default
                lineWidth: 1,
            }

            // transformNode (warp)
            // styleNode     (wrap)
            // shapeNode     (circle, rect, arc)

            radius = 70
            now = new Date()
            percent = Math.trunc(now.getMilliseconds()/10)

            tc = {
                x: size.width/2,
                y: size.height/2            
            }
          
            if (paper.DEBUG) {
                tc = {
                    x:180,
                    y:130
                }
            }

            var c = transform(
                tc,
                cell(radius,s,percent)
            )

            dt = {
                x: 360,
                y: 120,
                sx:   1,
                sy:  -1, // (0,0) lower left
            }

            if (paper.DEBUG) {
                dt = {
                     x: 230,
                     y: 460,
                    sx:   2,
                    sy:  -2, // (0,0) lower left
                }
            }

            var d = transform(dt,
                diagram(s)
            )
            
            group([
                c,
                d
            ])()
                       
            // Next loop
            // window.requestAnimationFrame(draw)
        } 
    </script>
</head>
<body onload="init();draw();">
    <h1>Scene</h1>
    <canvas id="scene" width="500" height="500" style="border:1px solid grey"></canvas>
</body>
</html>
